{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  },
  "AllowedHosts": "*",
  "ConnectionStrings": {
    "DefaultConnection": ""
  }

}





// necesario instalar las dependencias para usar ORM:
//Microsoft.EntityFrameworkCore  - el nucleo de EF Core, contiene toda la base para usar ORM
//Microsoft.EntityFrameworkCore.Relational - provee las bases para trabajar con bases de datos relacionales
//Microsoft.EntityFrameworkCore.Sqlite - Permite a EF core trabajar con una base de datos SQLite EN ESTE CASO ESTA NO SE OCUPA!!!!!!!!!!!!!!!!!!!!!!!!
//Microsoft.EntityFrameworkCore.Design - te permite crear migraciones usando dotnet ef migrations add <nombre> y ejecutar dotnet ef database update (es necesario para usar comandos dotner ef y generar codigo EF Core)
// Microsoft.Data.Sqlite - no es parte de EF Core pero Es el motor de conexión directa a SQLite. EF Core lo usa por debajo.

// Npgsql.EntityFrameworkCore.PostgreSQL - Permite a EF core trabajar con una base de datos PostgreSQL

// Opcional (no lo instale en este proyecto)
//Microsoft.VisualStudio.Web.CodeGeneration.Design - pertenece al scaffolding de ASP.NET MVC Generar automáticamente controladores y vistas basados en tus modelos (CRUD). NO ES ESTRICTAMENTE NECESARIO. Permite generar controladores, vistas y páginas automáticamente desde modelos (scaffolding).



//usar dotnet add package <nombre>

// y dotnet tool install --global dotnet-ef       CLI de EF Core para crear y utilizar las migraciones.


//Comandos:
// dotnet ef migrations add <NombreDeLaMigracion>  -> crea una migracion con los cambios que haya en el modelo de datos. Es decir si haces cambios en tu modelo de datos (clases) y quieres que esos cambios se vean reflejados en la base de datos, debes crear una migracion con este comando.

// dotnet ef database update  -> aplica las migraciones pendientes a la base de datos (crea la base de datos si no existe) este comando lee las migraciones que no han sido aplicadas a la base de datos y las aplica en orden. Si la base de datos no existe, la crea y luego aplica todas las migraciones.


// para utilizar passwords secretas: dotnet tool install --global dotnet-user-secrets
// despues correr en la terminal: dotnet user-secrets init

//to creará un UserSecretsId en tu archivo .csproj:
// despues en la terminal: dotnet user-secrets set "SUPABASE_PASSWORD" "12345SoundTrack12345!"

// con dotnet user-secrets list yo puedo recuperar las variables secretas que he creado

  // dotnet user-secrets set "ConnectionStrings:DefaultConnection" "SupabaseConnection = Host=db.ywzspxwxcqzyhttjrbrh.supabase.co;Database=postgres;Username=postgres;Password=12345SoundTrack12345!SSL Mode=Require;Trust Server Certificate=true"

